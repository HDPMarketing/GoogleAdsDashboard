// Hi-Desert Plumbing Marketing Performance Automation
// Auto-configured for your Google Sheets and Drive folder

const SPREADSHEET_ID = '1BsAd-0ApnbY15-zlT8T-N844KpOlC6OT01TuKVNXXMo';
const FOLDER_ID = '1Qq9JoNtMyvdsts4ZUbyBPgOF_kJJOJyM';
const YOUR_EMAIL = 'your-email@example.com'; // UPDATE THIS WITH YOUR EMAIL

function onInstall() {
  // Set up folder monitoring trigger
  setupFolderTrigger();
  console.log('Hi-Desert Plumbing Marketing Automation installed successfully!');
}

function setupFolderTrigger() {
  // Delete existing triggers
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === 'checkForNewFiles') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create hourly trigger to check for new PDFs
  ScriptApp.newTrigger('checkForNewFiles')
    .timeBased()
    .everyHours(1)
    .create();
}

function checkForNewFiles() {
  try {
    const folder = DriveApp.getFolderById(FOLDER_ID);
    const files = folder.getFiles();
    
    while (files.hasNext()) {
      const file = files.next();
      if (file.getMimeType() === 'application/pdf' && !isFileProcessed(file.getId())) {
        console.log(`Processing new PDF: ${file.getName()}`);
        processMarketingReport(file);
        markFileAsProcessed(file.getId());
      }
    }
  } catch (error) {
    console.error('Error checking for files:', error);
    sendNotification('Error checking for new marketing reports', error.toString());
  }
}

function processMarketingReport(file) {
  try {
    // Simpler approach: Create a temporary Google Doc to extract text
    const blob = file.getBlob();
    
    // Create temporary folder for processing if it doesn't exist
    let tempFolder;
    try {
      tempFolder = DriveApp.getFolderById(FOLDER_ID).getFoldersByName('_temp_processing').next();
    } catch (e) {
      tempFolder = DriveApp.getFolderById(FOLDER_ID).createFolder('_temp_processing');
    }
    
    // Create temporary Google Doc from PDF
    const tempDoc = DriveApp.createFile(blob).moveTo(tempFolder);
    
    // Try to get text content - this is a simplified approach
    let text = '';
    try {
      // For now, let's create a manual text extraction approach
      console.log('PDF detected:', file.getName());
      text = `MANUAL_EXTRACTION_NEEDED_${file.getName()}`;
    } catch (textError) {
      console.log('Text extraction issue:', textError);
      text = `ERROR_EXTRACTING_${file.getName()}`;
    }
    
    // Clean up temporary file
    tempDoc.setTrashed(true);
    
    // Extract marketing data
    const marketingData = extractMarketingMetrics(text, file.getName());
    
    if (marketingData) {
      updateSpreadsheet(marketingData);
      sendNotification('Marketing Report Processed Successfully', 
        `Processed: ${file.getName()}\nMonth: ${marketingData.month}\nGoogle Ads Spend: $${marketingData.googleAdsSpend}`);
    } else {
      sendNotification('No Marketing Data Found', `Could not extract data from: ${file.getName()}`);
    }
    
  } catch (error) {
    console.error('Error processing file:', error);
    sendNotification('Error Processing Marketing Report', `File: ${file.getName()}\nError: ${error.toString()}`);
  }
}

function extractMarketingMetrics(text, fileName) {
  console.log('Extracting metrics from:', fileName);
  
  // Determine month from filename or content
  const month = extractMonth(fileName, text);
  if (!month) {
    console.log('Could not determine month from file');
    return null;
  }
  
  const data = {
    month: month,
    seoSessions: extractSEOSessions(text),
    seoUsers: extractSEOUsers(text),
    seoBounceRate: extractSEOBounceRate(text),
    googleAdsSpend: extractGoogleAdsSpend(text),
    googleAdsClicks: extractGoogleAdsClicks(text),
    googleAdsConversions: extractGoogleAdsConversions(text),
    googleAdsConversionRate: 0, // Will calculate
    googleAdsCostPerConversion: 0, // Will calculate
    lsaSpend: extractLSASpend(text),
    lsaCalls: extractLSACalls(text),
    lsaLeads: extractLSALeads(text),
    lsaCostPerLead: 0, // Will calculate
    gbpImpressions: extractGBPImpressions(text),
    gbpCalls: extractGBPCalls(text),
    lastUpdated: new Date().toISOString()
  };
  
  // Calculate derived metrics
  if (data.googleAdsSpend && data.googleAdsConversions && data.googleAdsConversions > 0) {
    data.googleAdsCostPerConversion = (data.googleAdsSpend / data.googleAdsConversions).toFixed(2);
  }
  
  if (data.googleAdsClicks && data.googleAdsConversions) {
    data.googleAdsConversionRate = ((data.googleAdsConversions / data.googleAdsClicks) * 100).toFixed(2);
  }
  
  if (data.lsaSpend && data.lsaLeads && data.lsaLeads > 0) {
    data.lsaCostPerLead = (data.lsaSpend / data.lsaLeads).toFixed(2);
  }
  
  data.totalSpend = (data.googleAdsSpend || 0) + (data.lsaSpend || 0);
  data.totalLeadsConversions = (data.googleAdsConversions || 0) + (data.lsaLeads || 0);
  
  if (data.totalSpend && data.totalLeadsConversions && data.totalLeadsConversions > 0) {
    data.overallCostPerLead = (data.totalSpend / data.totalLeadsConversions).toFixed(2);
  }
  
  console.log('Extracted data:', data);
  return data;
}

function extractMonth(fileName, text) {
  // Try filename first
  const monthRegex = /(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\s*(\d{4})?/i;
  
  let match = fileName.match(monthRegex);
  if (match) {
    return match[1] + (match[2] ? ' ' + match[2] : ' 2025');
  }
  
  // Try text content
  match = text.match(monthRegex);
  if (match) {
    return match[1] + (match[2] ? ' ' + match[2] : ' 2025');
  }
  
  return null;
}

function extractGoogleAdsSpend(text) {
  const patterns = [
    /google\s*ads.*?cost[:\s]+\$?([\d,]+\.?\d*)/i,
    /adwords.*?spend[:\s]+\$?([\d,]+\.?\d*)/i,
    /google\s*ads.*?\$?([\d,]+\.?\d*)/i,
    /ppc.*?spend[:\s]+\$?([\d,]+\.?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseFloat(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractGoogleAdsConversions(text) {
  const patterns = [
    /google\s*ads.*?conversions?[:\s]+(\d+)/i,
    /adwords.*?conversions?[:\s]+(\d+)/i,
    /ppc.*?conversions?[:\s]+(\d+)/i,
    /conversions?[:\s]+(\d+)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1]);
    }
  }
  return null;
}

function extractLSASpend(text) {
  const patterns = [
    /local\s*services?.*?ads?.*?\$?([\d,]+\.?\d*)/i,
    /lsa.*?\$?([\d,]+\.?\d*)/i,
    /local\s*services?.*?\$?([\d,]+\.?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseFloat(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractLSALeads(text) {
  const patterns = [
    /local\s*services?.*?leads?[:\s]+(\d+)/i,
    /lsa.*?leads?[:\s]+(\d+)/i,
    /local\s*services?.*?(\d+)\s*leads?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1]);
    }
  }
  return null;
}

function extractGoogleAdsClicks(text) {
  const patterns = [
    /google\s*ads.*?clicks?[:\s]+(\d+,?\d*)/i,
    /adwords.*?clicks?[:\s]+(\d+,?\d*)/i,
    /ppc.*?clicks?[:\s]+(\d+,?\d*)/i,
    /clicks?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractLSACalls(text) {
  const patterns = [
    /local\s*services?.*?calls?[:\s]+(\d+)/i,
    /lsa.*?calls?[:\s]+(\d+)/i,
    /local\s*services?.*?(\d+)\s*calls?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1]);
    }
  }
  return null;
}

function extractGBPImpressions(text) {
  const patterns = [
    /business\s*profile.*?impressions?[:\s]+(\d+,?\d*)/i,
    /gbp.*?impressions?[:\s]+(\d+,?\d*)/i,
    /google.*?business.*?(\d+,?\d*)\s*impressions?/i,
    /impressions?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}
  const patterns = [
    /local\s*services?.*?leads?[:\s]+(\d+)/i,
    /lsa.*?leads?[:\s]+(\d+)/i,
    /local\s*services?.*?(\d+)\s*leads?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1]);
    }
  }
  return null;
}

function extractSEOSessions(text) {
  const patterns = [
    /sessions?[:\s]+(\d+,?\d*)/i,
    /organic.*?sessions?[:\s]+(\d+,?\d*)/i,
    /seo.*?sessions?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractSEOUsers(text) {
  const patterns = [
    /users?[:\s]+(\d+,?\d*)/i,
    /organic.*?users?[:\s]+(\d+,?\d*)/i,
    /seo.*?users?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractSEOBounceRate(text) {
  const patterns = [
    /bounce\s*rate[:\s]+([\d.]+)%?/i,
    /organic.*?bounce[:\s]+([\d.]+)%?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseFloat(match[1]);
    }
  }
  return null;
}

function extractGBPViews(text) {
  const patterns = [
    /business\s*profile.*?views?[:\s]+(\d+,?\d*)/i,
    /gbp.*?views?[:\s]+(\d+,?\d*)/i,
    /google.*?business.*?(\d+,?\d*)\s*views?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractGBPActions(text) {
  const patterns = [
    /business\s*profile.*?actions?[:\s]+(\d+,?\d*)/i,
    /gbp.*?actions?[:\s]+(\d+,?\d*)/i,
    /google.*?business.*?(\d+,?\d*)\s*actions?/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractGBPCalls(text) {
  const patterns = [
    /business\s*profile.*?calls?[:\s]+(\d+,?\d*)/i,
    /gbp.*?calls?[:\s]+(\d+,?\d*)/i,
    /phone.*?calls?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractGBPDirections(text) {
  const patterns = [
    /directions?[:\s]+(\d+,?\d*)/i,
    /business\s*profile.*?directions?[:\s]+(\d+,?\d*)/i,
    /gbp.*?directions?[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function extractGBPWebsiteClicks(text) {
  const patterns = [
    /website\s*clicks?[:\s]+(\d+,?\d*)/i,
    /business\s*profile.*?website[:\s]+(\d+,?\d*)/i,
    /gbp.*?website[:\s]+(\d+,?\d*)/i
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1].replace(/,/g, ''));
    }
  }
  return null;
}

function updateSpreadsheet(data) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName('Monthly Data');
  
  if (!sheet) {
    throw new Error('Monthly Data sheet not found');
  }
  
  // Check if month already exists
  const existingData = sheet.getDataRange().getValues();
  let rowIndex = -1;
  
  for (let i = 1; i < existingData.length; i++) {
    if (existingData[i][0] === data.month) {
      rowIndex = i + 1; // +1 for 1-based indexing
      break;
    }
  }
  
  // If month doesn't exist, add new row
  if (rowIndex === -1) {
    rowIndex = existingData.length + 1;
  }
  
  // Update row with data using correct headers
  const row = [
    data.month,                           // Month
    data.seoSessions || '',              // SEO Sessions
    data.seoUsers || '',                 // SEO New Users
    data.seoBounceRate || '',            // Bounce Rate %
    data.googleAdsSpend || '',           // Google Ads Spend
    data.googleAdsClicks || '',          // GA Clicks
    data.googleAdsConversions || '',     // GA Conversions
    data.googleAdsConversionRate || '',  // GA Conv Rate %
    data.googleAdsCostPerConversion || '',// GA Cost/Conv
    data.lsaSpend || '',                 // LSA Spend
    data.lsaCalls || '',                 // LSA Calls
    data.lsaLeads || '',                 // LSA Leads
    data.lsaCostPerLead || '',           // LSA Cost/Lead
    data.totalSpend || '',               // Total Spend
    data.totalLeadsConversions || '',    // Total Conversions
    data.overallCostPerLead || '',       // Overall Cost/Conv
    data.gbpImpressions || '',           // GBP Impressions
    data.gbpCalls || '',                 // GBP Calls
    data.lastUpdated                     // Last Updated
  ];
  
  sheet.getRange(rowIndex, 1, 1, row.length).setValues([row]);
  console.log(`Updated row ${rowIndex} for ${data.month}`);
}

function isFileProcessed(fileId) {
  try {
    const properties = PropertiesService.getScriptProperties();
    return properties.getProperty(`processed_${fileId}`) === 'true';
  } catch (error) {
    return false;
  }
}

function markFileAsProcessed(fileId) {
  const properties = PropertiesService.getScriptProperties();
  properties.setProperty(`processed_${fileId}`, 'true');
}

function sendNotification(subject, body) {
  if (YOUR_EMAIL && YOUR_EMAIL !== 'your-email@example.com') {
    try {
      MailApp.sendEmail({
        to: YOUR_EMAIL,
        subject: `Hi-Desert Plumbing Marketing: ${subject}`,
        body: body
      });
    } catch (error) {
      console.error('Failed to send notification:', error);
    }
  }
}

// Manual functions for testing
function testProcessing() {
  checkForNewFiles();
}

function debugProcessing() {
  console.log('=== DEBUGGING PDF PROCESSING ===');
  
  try {
    const folder = DriveApp.getFolderById(FOLDER_ID);
    const files = folder.getFiles();
    
    let fileCount = 0;
    while (files.hasNext()) {
      const file = files.next();
      fileCount++;
      console.log(`File ${fileCount}: ${file.getName()} (${file.getMimeType()})`);
      
      if (file.getMimeType() === 'application/pdf') {
        console.log(`Processing PDF: ${file.getName()}`);
        
        // Check if already processed
        const isProcessed = isFileProcessed(file.getId());
        console.log(`Already processed: ${isProcessed}`);
        
        if (!isProcessed) {
          // Extract text and see what we get
          debugPDFExtraction(file);
        } else {
          console.log('Skipping - already processed. Run resetProcessedFiles() to test again.');
        }
      }
    }
    
    if (fileCount === 0) {
      console.log('❌ No files found in folder!');
    }
    
  } catch (error) {
    console.error('❌ Debug error:', error);
  }
}

function debugPDFExtraction(file) {
  try {
    console.log('--- Starting PDF text extraction ---');
    
    // Extract text from PDF using OCR
    const blob = file.getBlob();
    const resource = {
      title: `DEBUG_${file.getName()}`,
      parents: [FOLDER_ID]
    };
    
    console.log('Converting PDF to Google Doc...');
    const doc = Drive.Files.insert(resource, blob, {
      convert: true,
      ocr: true
    });
    
    console.log('Reading extracted text...');
    const docFile = DriveApp.getFileById(doc.id);
    const text = DocumentApp.openById(doc.id).getBody().getText();
    
    console.log('--- EXTRACTED TEXT (first 500 chars) ---');
    console.log(text.substring(0, 500));
    console.log('--- END EXTRACTED TEXT ---');
    
    // Clean up temporary document
    DriveApp.getFileById(doc.id).setTrashed(true);
    
    // Try to extract marketing data
    console.log('--- Testing data extraction ---');
    const marketingData = extractMarketingMetrics(text, file.getName());
    console.log('Extracted marketing data:', marketingData);
    
    if (marketingData) {
      console.log('✅ Data extracted successfully!');
    } else {
      console.log('❌ No marketing data found');
    }
    
  } catch (error) {
    console.error('❌ PDF extraction error:', error);
  }
}

function resetProcessedFiles() {
  const properties = PropertiesService.getScriptProperties();
  properties.deleteAllProperties();
  console.log('Reset all processed file markers');
}
